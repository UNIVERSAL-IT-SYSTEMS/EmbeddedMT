#include <vector>
#include <iostream>

typedef int8_t region_t;
const region_t MINIMUM_REGION_SIZE = 2;
const uint8_t MASK_WIDTH_ONE_SIDE = 1;
const uint8_t PIXEL_ALREADY_CONSIDERED = 0xFF;  // Must not be 0 or a value in which only one bit is 1

typedef struct point
{
    uint32_t x;
    uint32_t y;
} point_t;


void printImage(const uint8_t* const image, const uint32_t sizeX, const uint32_t sizeY) {
    std::cout << "[" << std::endl;
    for(uint32_t i = 0; i < sizeY; i++) {
        for(uint32_t j = 0; j < sizeX; j++) {
            std::cout << std::hex << int(image[i*sizeX + j]) << "\t";
        }
        std::cout << std::endl;
    }
    std::cout << "]" << std::endl;
}

void printContour(const std::vector<std::vector<point_t> >& contours, const uint32_t sizeX, const uint32_t sizeY) {
   uint8_t newImage[sizeX*sizeY+1]; 
   // Nulify image
   for(uint32_t i = 0; i < sizeY; i++) {
        for(uint32_t j = 0; j < sizeX; j++) {
            newImage[i * sizeX + j] = 0;
        }
   }

   uint32_t value = 0;
    for (std::vector<std::vector<point_t > >::const_iterator contour = contours.begin() ; contour != contours.end(); ++contour) {
        value++;

        for(std::vector<point_t>::const_iterator point = contour->begin(); point != contour->end(); ++point) {
            newImage[point->y * sizeX + point->x] += value;        
        }
    }
    printImage(newImage, sizeX, sizeY);
}

void andWithNeighbouringPixels(const uint8_t* const image, const uint32_t sizeX, const uint32_t sizeY, uint8_t* const resultImage)
{
    // Mask:
    // 0 1 0
    // 1 1 1
    // 0 1 0
    
    // Fill border with 0's
    for(uint32_t i = 0; i < sizeY; i++) {
        for(uint32_t j = 0; j < MASK_WIDTH_ONE_SIDE; j++) {
            resultImage[i * sizeX + j] = 0;
            resultImage[i * sizeX + sizeX - 1 - j] = 0;
        }
    }
    for(uint32_t i = 0; i < MASK_WIDTH_ONE_SIDE; i++) {
        for(uint32_t j = 0; j < sizeX; j++) {
            resultImage[i * sizeX + j] = 0;
            resultImage[(sizeY - i - 1)* sizeX + j] = 0;
        }
    }

    for(uint32_t i = MASK_WIDTH_ONE_SIDE; i < sizeY - MASK_WIDTH_ONE_SIDE; i++) {
       for(uint32_t j = MASK_WIDTH_ONE_SIDE; j < sizeX - MASK_WIDTH_ONE_SIDE; j++) {
           uint8_t andedValue = image[i * sizeX + j];
           // Apply the mask
           for(region_t k = 1; k <= MASK_WIDTH_ONE_SIDE; k++) {
               // Horizontal displacement
                andedValue &= image[i * sizeX + j - k] & image[i * sizeX + j + k];
                // Vertical displacement
                andedValue &= image[(i - k) * sizeX + j] & image[(i+k) * sizeX + j];
           }
            resultImage[i * (sizeX*MASK_WIDTH_ONE_SIDE) + j] = andedValue;
       }
    }
}

bool mustAddPoint(const uint8_t* const image, uint32_t sizeX, uint32_t sizeY, const point_t& pointToSearch) {
    if(image[pointToSearch.y * sizeX + pointToSearch.x] != PIXEL_ALREADY_CONSIDERED) {
        return true;
    }
    return false;
}

std::vector<point_t> growUniformRegion(point_t& startingPoint, uint8_t* const image, const uint32_t sizeX, const uint32_t sizeY, uint32_t* regionSize) {
    const uint8_t regionValue = image[startingPoint.y*sizeX + startingPoint.x]; 
    std::vector<point_t> contour;
    contour.push_back(startingPoint);

    bool pointsAddedToRegion = false;
    do {
        pointsAddedToRegion = false;
        const size_t nbOfIterations = contour.size();
        for(size_t j = 0; j < nbOfIterations; j++) {
            point_t it = contour[j];
            if( image[it.y * sizeX + it.x] == regionValue ) {
                uint32_t pointX = it.x;
                uint32_t pointY = it.y;
                // Add all neighbours to the region
                for(region_t i = 1; i <= MASK_WIDTH_ONE_SIDE; i++) {
                    point_t neighbouringPoint;
                    neighbouringPoint.y = pointY;

                    // Check horizontal direction
                    // A vector should not have holes and since we will overwrite the current element, we might as well overwrite it with the new data     
                    neighbouringPoint.x = pointX - i;
                    if(mustAddPoint(image, sizeX, sizeY, neighbouringPoint)) {
                        contour.push_back(neighbouringPoint);
                    }

                    neighbouringPoint.x = pointX + i;
                    if(mustAddPoint(image, sizeX, sizeY, neighbouringPoint)) {
                        contour.push_back(neighbouringPoint);
                    }

                    // Reset x
                    neighbouringPoint.x = pointX;

                    // Check vertical direction
                    neighbouringPoint.y = pointY - i;
                    if(mustAddPoint(image, sizeX, sizeY, neighbouringPoint)) {
                        contour.push_back(neighbouringPoint);
                    }

                    neighbouringPoint.y = pointY + i;
                    if(mustAddPoint(image, sizeX, sizeY, neighbouringPoint)) {
                        contour.push_back(neighbouringPoint);
                    }

                    // We need to remove the current point. Since this is a vector, we may as well overwrite it with de last written data
                    contour[j].x = contour.back().x;
                    contour[j].y = contour.back().y;
                    contour.pop_back();

                    pointsAddedToRegion = true;
                }
                // Set pixel value of image to PIXEL_ALREADY_CONSIDERED
                image[pointY*sizeX + pointX] = PIXEL_ALREADY_CONSIDERED;
            }
        }
        std::vector<std::vector<point_t> > contours;
        contours.push_back(contour);
        printContour(contours, sizeX, sizeY);
    }
    while (pointsAddedToRegion);

    // TODO
    *regionSize = 10;
    return contour;
}

std::vector<std::vector<point_t> > growUniformRegions(uint8_t* const image, const uint32_t sizeX, const uint32_t sizeY) {
    // Try to grow points at a distance of MINIMUM_REGION_SIZE from each other
    std::vector<std::vector<point_t> > foundRegions;
    point_t growPoint = { MINIMUM_REGION_SIZE/2, MINIMUM_REGION_SIZE/2};
    while(growPoint.x < sizeX && growPoint.y < sizeY) {
        // If the growPoint is zero, we ignore it
        if(image[growPoint.y * sizeX + growPoint.x] != 0) {
            uint32_t regionSize = 0;
            std::vector<point_t> newRegion = growUniformRegion(growPoint, image, sizeX, sizeY, &regionSize);
            if(regionSize > MINIMUM_REGION_SIZE*MINIMUM_REGION_SIZE) { 
                foundRegions.push_back(newRegion);
            }
        }

        // Jump to next candidate point
        growPoint.x += MINIMUM_REGION_SIZE;
        growPoint.y += MINIMUM_REGION_SIZE;
    }
    return foundRegions;
}

std::vector<std::vector<point_t> > findContours(const uint8_t* const image, const uint32_t sizeX, const uint32_t sizeY) {
    // Assumption: the image was quantized where only one bit is non-zero. The non-zero bit defines to which quantization class the bit belongs
    // Step 1: And bits and all neighbouring bits. 
    uint8_t tmpImage[sizeX*sizeY+1];
    andWithNeighbouringPixels(image, sizeX, sizeY, tmpImage);

    // Step 2: Grow uniform regions
    std::vector<std::vector<point_t> > contours = growUniformRegions(tmpImage, sizeX, sizeY);
    return contours;
}

int main(int argc, char** argv) {
    const uint32_t imageLength = 10;
    uint8_t testImage[imageLength*imageLength + 1] = {  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 8, 8, 8, 8, 8, 8, 8, 8, 1,
                                                        1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

    printImage(testImage, imageLength, imageLength);
    std::vector<std::vector<point_t> > contours = findContours(testImage, imageLength, imageLength);

    printContour(contours, imageLength, imageLength);
    return 0;
}
